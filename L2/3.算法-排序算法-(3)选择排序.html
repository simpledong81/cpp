<html><head>
    <meta charset="UTF-8"><link rel="stylesheet" type="text/css" href="https://unpkg.com/vditor@3.10.8/dist/index.css"/>
<script src="https://unpkg.com/vditor@3.10.8/dist/js/i18n/zh_CN.js"></script>
<script src="https://unpkg.com/vditor@3.10.8/dist/method.min.js"></script></head>
<body><div class="vditor-reset" id="preview"><h3>选择排序（Selection Sort）</h3>
<h4>1. 什么是选择排序？</h4>
<p>选择排序是一种简单的排序算法。它的基本思想是每次从未排序部分选择最小（或最大）的元素，放到已排序部分的末尾。通过不断选择剩余元素中的最小（或最大）值，逐步构建有序序列。</p>
<hr />
<h4>2. 选择排序的基本思想</h4>
<ol>
<li><strong>划分数组</strong>：将数组分为已排序部分和未排序部分。</li>
<li><strong>选择最小元素</strong>：在未排序部分中找到最小元素。</li>
<li><strong>交换元素</strong>：将最小元素与未排序部分的第一个元素交换。</li>
<li><strong>更新边界</strong>：将已排序部分的边界向右移动一位。</li>
<li><strong>重复过程</strong>：直到未排序部分为空。</li>
</ol>
<hr />
<h4>3. 选择排序的步骤</h4>
<ol>
<li>从数组的第一个元素开始，假设它是未排序部分的最小元素。</li>
<li>遍历未排序部分，找到真正的最小元素。</li>
<li>将最小元素与未排序部分的第一个元素交换。</li>
<li>将已排序部分的边界向右移动一位。</li>
<li>重复上述过程，直到数组完全有序。</li>
</ol>
<hr />
<h4>4. 选择排序的代码实现</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

// 选择排序
void selectionSort(vector&lt;int&gt;&amp; arr) {
    int n = arr.size();
    for (int i = 0; i &lt; n - 1; i++) { // 外层循环控制已排序部分的边界
        int minIndex = i; // 假设未排序部分的第一个元素是最小元素
        for (int j = i + 1; j &lt; n; j++) { // 内层循环查找未排序部分的最小元素
            if (arr[j] &lt; arr[minIndex]) {
                minIndex = j; // 更新最小元素的索引
            }
        }
        if (minIndex != i) { // 如果找到更小的元素，交换它们的位置
            swap(arr[i], arr[minIndex]);
        }
    }
}

int main() {
    vector&lt;int&gt; arr = {64, 25, 12, 22, 11};

    cout &lt;&lt; &quot;排序前: &quot;;
    for (int num : arr) {
        cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;

    selectionSort(arr);

    cout &lt;&lt; &quot;排序后: &quot;;
    for (int num : arr) {
        cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code>排序前: 64 25 12 22 11 
排序后: 11 12 22 25 64
</code></pre>
<hr />
<h4>5. 选择排序的时间复杂度</h4>
<ul>
<li><strong>最坏情况</strong>：O(n²)，无论数组是否有序，都需要进行完整的比较和交换。</li>
<li><strong>最好情况</strong>：O(n²)，即使数组已经有序，仍然需要进行比较。</li>
<li><strong>平均情况</strong>：O(n²)。</li>
</ul>
<hr />
<h4>6. 选择排序的空间复杂度</h4>
<ul>
<li><strong>空间复杂度</strong>：O(1)，选择排序是原地排序算法，不需要额外空间。</li>
</ul>
<hr />
<h4>7. 选择排序的稳定性</h4>
<ul>
<li><strong>稳定性</strong>：不稳定。选择排序可能会改变相等元素的相对顺序。</li>
</ul>
<p><strong>示例</strong>：<br />
假设数组为 <code>[5, 5, 2]</code>，选择排序的过程如下：</p>
<ol>
<li>找到最小元素 <code>2</code>，与第一个 <code>5</code> 交换，数组变为 <code>[2, 5, 5]</code>。</li>
<li>第二个 <code>5</code> 和第三个 <code>5</code> 的相对顺序被改变。</li>
</ol>
<hr />
<h4>8. 选择排序的优缺点</h4>
<ul>
<li><strong>优点</strong>：
<ul>
<li>实现简单，代码易于理解。</li>
<li>原地排序，不需要额外空间。</li>
<li>对于小规模数据，性能可以接受。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>时间复杂度较高，不适合大规模数据。</li>
<li>不稳定，可能会改变相等元素的相对顺序。</li>
</ul>
</li>
</ul>
<hr />
<h4>9. 选择排序的应用</h4>
<ul>
<li><strong>教学用途</strong>：由于实现简单，常用于算法教学。</li>
<li><strong>小规模数据排序</strong>：当数据规模较小时，选择排序的性能可以接受。</li>
<li><strong>内存受限的环境</strong>：由于选择排序是原地排序，适合内存受限的环境。</li>
</ul>
<hr />
<h4>10. 总结</h4>
<p>选择排序是一种简单但效率较低的排序算法，适用于小规模数据或教学用途。虽然它的时间复杂度较高，但由于实现简单，仍然有一定的应用价值。掌握选择排序的思想和实现方法，有助于理解更复杂的排序算法。</p>
</div>
<script>
    const previewElement = document.getElementById('preview')
    Vditor.setContentTheme('light', 'https://unpkg.com/vditor@3.10.8/dist/css/content-theme');
    Vditor.codeRender(previewElement);
    Vditor.highlightRender({"enable":true,"lineNumber":false,"defaultLang":"","style":"github"}, previewElement, 'https://unpkg.com/vditor@3.10.8');
    Vditor.mathRender(previewElement, {
        cdn: 'https://unpkg.com/vditor@3.10.8',
        math: {"engine":"KaTeX","inlineDigit":false,"macros":{}},
    });
    Vditor.mermaidRender(previewElement, 'https://unpkg.com/vditor@3.10.8', 'classic');
    Vditor.SMILESRender(previewElement, 'https://unpkg.com/vditor@3.10.8', 'classic');
    Vditor.markmapRender(previewElement, 'https://unpkg.com/vditor@3.10.8');
    Vditor.flowchartRender(previewElement, 'https://unpkg.com/vditor@3.10.8');
    Vditor.graphvizRender(previewElement, 'https://unpkg.com/vditor@3.10.8');
    Vditor.chartRender(previewElement, 'https://unpkg.com/vditor@3.10.8', 'classic');
    Vditor.mindmapRender(previewElement, 'https://unpkg.com/vditor@3.10.8', 'classic');
    Vditor.abcRender(previewElement, 'https://unpkg.com/vditor@3.10.8');
    Vditor.mediaRender(previewElement);
    Vditor.speechRender(previewElement);
</script>
<script src="https://unpkg.com/vditor@3.10.8/dist/js/icons/ant.js"></script></body></html>