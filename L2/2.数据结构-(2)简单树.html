<html><head><link rel="stylesheet" type="text/css" href="https://unpkg.com/vditor@3.10.8/dist/index.css"/>
<script src="https://unpkg.com/vditor@3.10.8/dist/js/i18n/zh_CN.js"></script>
<script src="https://unpkg.com/vditor@3.10.8/dist/method.min.js"></script></head>
<body><div class="vditor-reset" id="preview"><p>树是一种重要的非线性数据结构，常用于表示层次关系。以下是树的定义、表示、存储以及二叉树的定义、性质和遍历的详细说明：</p>
<hr />
<h3><strong>1. 树的定义与相关概念</strong></h3>
<h4><strong>(1) 树的定义</strong></h4>
<ul>
<li><strong>树</strong>：由 ( n ) 个节点组成的有限集合，满足以下条件：
<ul>
<li>有一个特殊的节点称为<strong>根节点</strong>。</li>
<li>其余节点分为 ( m ) 个互不相交的子树，每棵子树也是一棵树。</li>
</ul>
</li>
</ul>
<h4><strong>(2) 相关概念</strong></h4>
<ul>
<li><strong>节点</strong>：树中的每个元素。</li>
<li><strong>根节点</strong>：树的顶层节点，没有父节点。</li>
<li><strong>子节点</strong>：一个节点的直接下级节点。</li>
<li><strong>父节点</strong>：一个节点的直接上级节点。</li>
<li><strong>叶子节点</strong>：没有子节点的节点。</li>
<li><strong>深度</strong>：从根节点到当前节点的路径长度。</li>
<li><strong>高度</strong>：从当前节点到叶子节点的最长路径长度。</li>
<li><strong>度</strong>：一个节点的子节点数量。</li>
</ul>
<hr />
<h3><strong>2. 树的表示与存储</strong></h3>
<h4><strong>(1) 双亲表示法</strong></h4>
<ul>
<li>每个节点存储其数据和父节点的索引。</li>
<li>适用于查找父节点的场景。</li>
</ul>
<h4><strong>(2) 孩子表示法</strong></h4>
<ul>
<li>每个节点存储其数据和子节点的指针。</li>
<li>适用于查找子节点的场景。</li>
</ul>
<h4><strong>(3) 孩子兄弟表示法</strong></h4>
<ul>
<li>每个节点存储其数据、第一个子节点的指针和下一个兄弟节点的指针。</li>
<li>适用于表示多叉树。</li>
</ul>
<hr />
<h3><strong>3. 二叉树的定义与基本性质</strong></h3>
<h4><strong>(1) 二叉树的定义</strong></h4>
<ul>
<li><strong>二叉树</strong>：每个节点最多有两个子节点（左子节点和右子节点）。</li>
</ul>
<h4><strong>(2) 基本性质</strong></h4>
<ul>
<li><strong>性质 1</strong>：二叉树的第 ( i ) 层最多有 ( 2^{i-1} ) 个节点。</li>
<li><strong>性质 2</strong>：深度为 ( k ) 的二叉树最多有 ( 2^k - 1 ) 个节点。</li>
<li><strong>性质 3</strong>：对于任何二叉树，叶子节点数 ( n_0 ) 和度为 2 的节点数 ( n_2 ) 满足 ( n_0 = n_2 + 1 )。</li>
</ul>
<hr />
<h3><strong>4. 二叉树的表示与存储</strong></h3>
<h4><strong>(1) 链式存储</strong></h4>
<ul>
<li>每个节点存储数据、左子节点指针和右子节点指针。</li>
<li><strong>节点结构</strong>：
<pre><code class="language-cpp">struct TreeNode {
    int data;
    TreeNode* left;
    TreeNode* right;
};
</code></pre>
</li>
</ul>
<h4><strong>(2) 顺序存储</strong></h4>
<ul>
<li>使用数组存储二叉树，按层次顺序存储节点。</li>
<li><strong>规则</strong>：
<ul>
<li>父节点索引为 ( i )，左子节点索引为 ( 2i + 1 )，右子节点索引为 ( 2i + 2 )。</li>
</ul>
</li>
</ul>
<hr />
<h3><strong>5. 二叉树的遍历</strong></h3>
<h4><strong>(1) 前序遍历（Preorder Traversal）</strong></h4>
<ul>
<li><strong>顺序</strong>：根节点 -&gt; 左子树 -&gt; 右子树。</li>
<li><strong>代码实现</strong>：
<pre><code class="language-cpp">void preorder(TreeNode* root) {
    if (root == nullptr) return;
    cout &lt;&lt; root-&gt;data &lt;&lt; &quot; &quot;;  // 访问根节点
    preorder(root-&gt;left);       // 遍历左子树
    preorder(root-&gt;right);      // 遍历右子树
}
</code></pre>
</li>
</ul>
<h4><strong>(2) 中序遍历（Inorder Traversal）</strong></h4>
<ul>
<li><strong>顺序</strong>：左子树 -&gt; 根节点 -&gt; 右子树。</li>
<li><strong>代码实现</strong>：
<pre><code class="language-cpp">void inorder(TreeNode* root) {
    if (root == nullptr) return;
    inorder(root-&gt;left);        // 遍历左子树
    cout &lt;&lt; root-&gt;data &lt;&lt; &quot; &quot;;  // 访问根节点
    inorder(root-&gt;right);       // 遍历右子树
}
</code></pre>
</li>
</ul>
<h4><strong>(3) 后序遍历（Postorder Traversal）</strong></h4>
<ul>
<li><strong>顺序</strong>：左子树 -&gt; 右子树 -&gt; 根节点。</li>
<li><strong>代码实现</strong>：
<pre><code class="language-cpp">void postorder(TreeNode* root) {
    if (root == nullptr) return;
    postorder(root-&gt;left);      // 遍历左子树
    postorder(root-&gt;right);     // 遍历右子树
    cout &lt;&lt; root-&gt;data &lt;&lt; &quot; &quot;;  // 访问根节点
}
</code></pre>
</li>
</ul>
<hr />
<h3><strong>6. 综合示例</strong></h3>
<p>以下是一个完整的C++程序，演示了二叉树的定义、存储和遍历：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

// 定义二叉树节点
struct TreeNode {
    int data;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int val) : data(val), left(nullptr), right(nullptr) {}
};

// 前序遍历
void preorder(TreeNode* root) {
    if (root == nullptr) return;
    cout &lt;&lt; root-&gt;data &lt;&lt; &quot; &quot;;  // 访问根节点
    preorder(root-&gt;left);       // 遍历左子树
    preorder(root-&gt;right);      // 遍历右子树
}

// 中序遍历
void inorder(TreeNode* root) {
    if (root == nullptr) return;
    inorder(root-&gt;left);        // 遍历左子树
    cout &lt;&lt; root-&gt;data &lt;&lt; &quot; &quot;;  // 访问根节点
    inorder(root-&gt;right);       // 遍历右子树
}

// 后序遍历
void postorder(TreeNode* root) {
    if (root == nullptr) return;
    postorder(root-&gt;left);      // 遍历左子树
    postorder(root-&gt;right);     // 遍历右子树
    cout &lt;&lt; root-&gt;data &lt;&lt; &quot; &quot;;  // 访问根节点
}

int main() {
    // 构建二叉树
    TreeNode* root = new TreeNode(1);
    root-&gt;left = new TreeNode(2);
    root-&gt;right = new TreeNode(3);
    root-&gt;left-&gt;left = new TreeNode(4);
    root-&gt;left-&gt;right = new TreeNode(5);

    // 前序遍历
    cout &lt;&lt; &quot;Preorder Traversal: &quot;;
    preorder(root);  // 输出：1 2 4 5 3
    cout &lt;&lt; endl;

    // 中序遍历
    cout &lt;&lt; &quot;Inorder Traversal: &quot;;
    inorder(root);  // 输出：4 2 5 1 3
    cout &lt;&lt; endl;

    // 后序遍历
    cout &lt;&lt; &quot;Postorder Traversal: &quot;;
    postorder(root);  // 输出：4 5 2 3 1
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>
<hr />
<h3><strong>7. 总结</strong></h3>
<table>
<thead>
<tr>
<th>概念/操作</th>
<th>说明</th>
<th>示例/代码</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>树的定义</strong></td>
<td>由节点和边组成的层次结构</td>
<td>根节点、子节点、叶子节点</td>
</tr>
<tr>
<td><strong>树的存储</strong></td>
<td>双亲表示法、孩子表示法、孩子兄弟表示法</td>
<td><code>TreeNode { int data; TreeNode* left; TreeNode* right; }</code></td>
</tr>
<tr>
<td><strong>二叉树性质</strong></td>
<td>第 ( i ) 层最多有 ( 2^{i-1} ) 个节点</td>
<td>深度为 ( k ) 的二叉树最多有 ( 2^k - 1 ) 个节点</td>
</tr>
<tr>
<td><strong>二叉树遍历</strong></td>
<td>前序、中序、后序遍历</td>
<td><code>preorder()</code>、<code>inorder()</code>、<code>postorder()</code></td>
</tr>
</tbody>
</table>
<p>树和二叉树是计算机科学中重要的数据结构，熟练掌握它们的定义、存储和遍历方法可以解决许多实际问题。</p>
</div>
<script>
    const previewElement = document.getElementById('preview')
    Vditor.setContentTheme('light', 'https://unpkg.com/vditor@3.10.8/dist/css/content-theme');
    Vditor.codeRender(previewElement);
    Vditor.highlightRender({"enable":true,"lineNumber":false,"defaultLang":"","style":"github"}, previewElement, 'https://unpkg.com/vditor@3.10.8');
    Vditor.mathRender(previewElement, {
        cdn: 'https://unpkg.com/vditor@3.10.8',
        math: {"engine":"KaTeX","inlineDigit":false,"macros":{}},
    });
    Vditor.mermaidRender(previewElement, 'https://unpkg.com/vditor@3.10.8', 'classic');
    Vditor.SMILESRender(previewElement, 'https://unpkg.com/vditor@3.10.8', 'classic');
    Vditor.markmapRender(previewElement, 'https://unpkg.com/vditor@3.10.8');
    Vditor.flowchartRender(previewElement, 'https://unpkg.com/vditor@3.10.8');
    Vditor.graphvizRender(previewElement, 'https://unpkg.com/vditor@3.10.8');
    Vditor.chartRender(previewElement, 'https://unpkg.com/vditor@3.10.8', 'classic');
    Vditor.mindmapRender(previewElement, 'https://unpkg.com/vditor@3.10.8', 'classic');
    Vditor.abcRender(previewElement, 'https://unpkg.com/vditor@3.10.8');
    Vditor.mediaRender(previewElement);
    Vditor.speechRender(previewElement);
</script>
<script src="https://unpkg.com/vditor@3.10.8/dist/js/icons/ant.js"></script></body></html>