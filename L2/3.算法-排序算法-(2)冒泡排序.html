<html><head><link rel="stylesheet" type="text/css" href="https://unpkg.com/vditor@3.10.8/dist/index.css"/>
<script src="https://unpkg.com/vditor@3.10.8/dist/js/i18n/zh_CN.js"></script>
<script src="https://unpkg.com/vditor@3.10.8/dist/method.min.js"></script></head>
<body><div class="vditor-reset" id="preview"><h3>冒泡排序（Bubble Sort）</h3>
<h4>1. 什么是冒泡排序？</h4>
<p>冒泡排序是一种简单的排序算法。它通过不断交换相邻元素，将最大（或最小）的元素“冒泡”到数组的末尾。每一轮排序都会将一个元素放到正确的位置。</p>
<hr />
<h4>2. 冒泡排序的基本思想</h4>
<ol>
<li><strong>比较相邻元素</strong>：从数组的第一个元素开始，依次比较相邻的两个元素。</li>
<li><strong>交换元素</strong>：如果顺序错误（例如前一个元素比后一个元素大），则交换它们的位置。</li>
<li><strong>重复过程</strong>：每一轮排序会将当前未排序部分的最大元素“冒泡”到末尾。</li>
<li><strong>终止条件</strong>：当某一轮排序没有发生任何交换时，说明数组已经有序，排序结束。</li>
</ol>
<hr />
<h4>3. 冒泡排序的步骤</h4>
<ol>
<li>从数组的第一个元素开始，比较相邻的两个元素。</li>
<li>如果顺序错误，交换它们的位置。</li>
<li>继续比较下一对相邻元素，直到数组末尾。</li>
<li>重复上述过程，直到数组完全有序。</li>
</ol>
<hr />
<h4>4. 冒泡排序的代码实现</h4>
<h5>方法 1：基础实现</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

// 冒泡排序
void bubbleSort(vector&lt;int&gt;&amp; arr) {
    int n = arr.size();
    for (int i = 0; i &lt; n - 1; i++) { // 外层循环控制轮数
        for (int j = 0; j &lt; n - 1 - i; j++) { // 内层循环进行比较和交换
            if (arr[j] &gt; arr[j + 1]) { // 如果顺序错误，交换相邻元素
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}

int main() {
    vector&lt;int&gt; arr = {64, 34, 25, 12, 22, 11, 90};

    cout &lt;&lt; &quot;排序前: &quot;;
    for (int num : arr) {
        cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;

    bubbleSort(arr);

    cout &lt;&lt; &quot;排序后: &quot;;
    for (int num : arr) {
        cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code>排序前: 64 34 25 12 22 11 90 
排序后: 11 12 22 25 34 64 90
</code></pre>
<hr />
<h5>方法 2：优化实现（提前终止）</h5>
<p>如果在某一轮排序中没有发生任何交换，说明数组已经有序，可以提前终止排序。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

// 冒泡排序（优化版）
void bubbleSortOptimized(vector&lt;int&gt;&amp; arr) {
    int n = arr.size();
    bool swapped; // 标记是否发生交换

    for (int i = 0; i &lt; n - 1; i++) {
        swapped = false; // 每轮开始时重置标记
        for (int j = 0; j &lt; n - 1 - i; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                swapped = true; // 发生交换
            }
        }
        if (!swapped) { // 如果没有发生交换，说明数组已经有序
            break;
        }
    }
}

int main() {
    vector&lt;int&gt; arr = {64, 34, 25, 12, 22, 11, 90};

    cout &lt;&lt; &quot;排序前: &quot;;
    for (int num : arr) {
        cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;

    bubbleSortOptimized(arr);

    cout &lt;&lt; &quot;排序后: &quot;;
    for (int num : arr) {
        cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code>排序前: 64 34 25 12 22 11 90 
排序后: 11 12 22 25 34 64 90
</code></pre>
<hr />
<h4>5. 冒泡排序的时间复杂度</h4>
<ul>
<li><strong>最坏情况</strong>：O(n²)，当数组完全逆序时。</li>
<li><strong>最好情况</strong>：O(n)，当数组已经有序时（优化版）。</li>
<li><strong>平均情况</strong>：O(n²)。</li>
</ul>
<hr />
<h4>6. 冒泡排序的空间复杂度</h4>
<ul>
<li><strong>空间复杂度</strong>：O(1)，冒泡排序是原地排序算法，不需要额外空间。</li>
</ul>
<hr />
<h4>7. 冒泡排序的稳定性</h4>
<ul>
<li><strong>稳定性</strong>：稳定。冒泡排序不会改变相等元素的相对顺序。</li>
</ul>
<hr />
<h4>8. 冒泡排序的优缺点</h4>
<ul>
<li><strong>优点</strong>：
<ul>
<li>实现简单，代码易于理解。</li>
<li>原地排序，不需要额外空间。</li>
<li>对于小规模数据或基本有序的数据，性能较好。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>时间复杂度较高，不适合大规模数据。</li>
<li>对于完全逆序的数据，性能较差。</li>
</ul>
</li>
</ul>
<hr />
<h4>9. 冒泡排序的应用</h4>
<ul>
<li><strong>教学用途</strong>：由于实现简单，常用于算法教学。</li>
<li><strong>小规模数据排序</strong>：当数据规模较小时，冒泡排序的性能可以接受。</li>
<li><strong>检测数组是否有序</strong>：通过优化版的冒泡排序，可以快速检测数组是否已经有序。</li>
</ul>
<hr />
<h4>10. 总结</h4>
<p>冒泡排序是一种简单但效率较低的排序算法，适用于小规模数据或教学用途。通过优化（如提前终止），可以在某些情况下提高性能。掌握冒泡排序的思想和实现方法，有助于理解更复杂的排序算法。</p>
</div>
<script>
    const previewElement = document.getElementById('preview')
    Vditor.setContentTheme('light', 'https://unpkg.com/vditor@3.10.8/dist/css/content-theme');
    Vditor.codeRender(previewElement);
    Vditor.highlightRender({"enable":true,"lineNumber":false,"defaultLang":"","style":"github"}, previewElement, 'https://unpkg.com/vditor@3.10.8');
    Vditor.mathRender(previewElement, {
        cdn: 'https://unpkg.com/vditor@3.10.8',
        math: {"engine":"KaTeX","inlineDigit":false,"macros":{}},
    });
    Vditor.mermaidRender(previewElement, 'https://unpkg.com/vditor@3.10.8', 'classic');
    Vditor.SMILESRender(previewElement, 'https://unpkg.com/vditor@3.10.8', 'classic');
    Vditor.markmapRender(previewElement, 'https://unpkg.com/vditor@3.10.8');
    Vditor.flowchartRender(previewElement, 'https://unpkg.com/vditor@3.10.8');
    Vditor.graphvizRender(previewElement, 'https://unpkg.com/vditor@3.10.8');
    Vditor.chartRender(previewElement, 'https://unpkg.com/vditor@3.10.8', 'classic');
    Vditor.mindmapRender(previewElement, 'https://unpkg.com/vditor@3.10.8', 'classic');
    Vditor.abcRender(previewElement, 'https://unpkg.com/vditor@3.10.8');
    Vditor.mediaRender(previewElement);
    Vditor.speechRender(previewElement);
</script>
<script src="https://unpkg.com/vditor@3.10.8/dist/js/icons/ant.js"></script></body></html>